## URL 解析
### 地址解析
### 编码

## 缓存检查

### 强缓存 Expires / Cache-Control

> 浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的
> - Expires：缓存过期时间，用来指定资源到期的时间（HTTP/1.0）

> - Cache-Control：cache-control: max-age=2592000第一次拿到资源后的2592000秒内（30天），再次发送请求，读取缓存中的信息（HTTP/1.1）

> - 两者同时存在的话，Cache-Control优先级高于Expires

### 协商缓存 Last-Modified / ETag

> 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程

每次都发送请求，让服务器来判断

-----

需要更新文件
强缓存时可以修改文件hash或者后缀名来更新文件
或者使用协商缓存。

## DNS解析

1. 递归查询
客户端 => 浏览器缓存 => 本地hosts文件 => 本地DNS解析器缓存 => 本地DNS服务器
2. 迭代查询
本地DNS服务器 <=> 根域名服务器
本地DNS服务器 <=> 顶级名服务器
本地DNS服务器 <=> 权威名服务器

优化点：
-  减少DNS请求，一个页面尽可能使用相同域名。
-  DNS预处理，使用link标签提前访问域名，提前解析DNS。
```js
<link rel="dns-prefetch" href="https://www.baidu.com">
```

## TCP三次握手
客户端  发送 SYN=1 seq=x
服务端  发送 SYN=1 seq=y ACK=1 ack=x+1
客户端  发送 seq=x+1 ACK=1 ack=y+1

### 为什么是三次
服务端需要确认客户端知道自己知道，即需要客户端告诉服务端，我客户端知道了。也就是第三次握手存在的意义。然后服务端知道会有人来，才能开启连接

假设是2次，不能保证可靠性，服务端不确定客户端有没有收到【服务的传给客户端的】确认的信息
假设是4次，多余


## 数据传输
- HTTP 报文
- 响应状态码
- - 200
- - 300
- - 400
- - 500

## TCP四次挥手  

### 为什么是四次
服务器端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文

但关闭连接时，当服务器端收到FIN报文时，很可能并不会立即关闭链接，所以只能先回复一个ACK报文，告诉客户端：”你发的FIN报文我收到了”

只有等到服务器端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四步握手。


### HTTP1.0和HTTP1.1的一些区别
Connection: keep-alive

HTTP 1.0 手动开启
HTTP 1.1 默认开启


- 缓存处理，HTTP1.0中主要使用 Last-Modified，Expires 来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略：ETag，Cache-Control…

- 带宽优化及网络连接的使用，HTTP1.1支持断点续传，即返回码是206（Partial Content）

- 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除…

- Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）

- 长连接，HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点

### HTTP2.0和HTTP1.X相比的新特性

- 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合，基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮

- header压缩，HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小

- 服务端推送（server push），例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了

```js
// 通过在应用生成HTTP响应头信息中设置Link命令
Link: </styles.css>; rel=preload; as=style, </example.png>; rel=preload; as=image
```
- 多路复用（MultiPlexing）

   - HTTP/1.0  每次请求响应，建立一个TCP连接，用完关闭
   - HTTP/1.1 「长连接」 若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；例子： Chrome 有个机制,同一个域名同时最多只能建立 6 个 TCP 连接 建立TCP 连接
   - HTTP/2.0 「多路复用」多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行；